name: Build and Publish

on:
  schedule:
  # Run on the 1st and 15th of every month (≈ every 2 weeks)
  - cron: "0 6 1,15 * *"
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: "Force rebuild even if the version tag already exists"
        required: false
        type: boolean
        default: true
      tools:
        description: "Comma-separated list of tools to build (leave empty for all)"
        required: false
        type: string
        default: ""

permissions:
  contents: write # create releases
  packages: write # push to ghcr.io

jobs:
  # ── Matrix setup ───────────────────────────────────────────────────────────
  matrix:
    runs-on: ubuntu-latest
    outputs:
      tools: ${{ steps.set-matrix.outputs.tools }}
    steps:
    - name: Determine tool matrix
      id: set-matrix
      run: |
        if [ -n "${{ inputs.tools }}" ]; then
          # Convert comma-separated input to JSON array
          TOOLS=$(echo '${{ inputs.tools }}' | tr ',' '\n' | sed 's/^ *//;s/ *$//' | jq -R . | jq -sc .)
        else
          TOOLS='["kubeconform","gitleaks"]'
        fi
        echo "tools=${TOOLS}" >> "$GITHUB_OUTPUT"
        echo "Building tools: ${TOOLS}"

  # ── Build each tool ────────────────────────────────────────────────────────
  build:
    needs: matrix
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        tool: ${{ fromJSON(needs.matrix.outputs.tools) }}

    steps:
    # ── Checkout ──────────────────────────────────────────────────────────
    - name: Checkout repository
      uses: actions/checkout@v4

    # ── Resolve versions (kubeconform) ─────────────────────────────────────
    - name: Get latest kubeconform version
      if: matrix.tool == 'kubeconform'
      id: kubeconform
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        VERSION=$(gh release view --repo yannh/kubeconform --json tagName -q .tagName)
        echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
        echo "kubeconform: ${VERSION}"

    - name: Get latest kustomize version
      if: matrix.tool == 'kubeconform'
      id: kustomize
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        VERSION=$(gh api repos/kubernetes-sigs/kustomize/releases \
          --jq '[.[] | select(.tag_name | startswith("kustomize/")) | select(.prerelease == false)] | first | .tag_name | ltrimstr("kustomize/")')
        echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
        echo "kustomize: ${VERSION}"

    # ── Resolve versions (gitleaks) ────────────────────────────────────────
    - name: Get latest gitleaks version
      if: matrix.tool == 'gitleaks'
      id: gitleaks
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        VERSION=$(gh release view --repo gitleaks/gitleaks --json tagName -q '.tagName | ltrimstr("v")')
        echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
        echo "gitleaks: ${VERSION}"

    # ── Compute unified version tag ────────────────────────────────────────
    - name: Set version tag
      id: version
      run: |
        if [ "${{ matrix.tool }}" = "kubeconform" ]; then
          TAG="${{ steps.kubeconform.outputs.version }}"
        elif [ "${{ matrix.tool }}" = "gitleaks" ]; then
          TAG="v${{ steps.gitleaks.outputs.version }}"
        fi
        RELEASE_TAG="${{ matrix.tool }}-${TAG}"
        echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
        echo "release_tag=${RELEASE_TAG}" >> "$GITHUB_OUTPUT"
        echo "Version tag: ${TAG}, Release tag: ${RELEASE_TAG}"

    # ── Skip guard ─────────────────────────────────────────────────────────
    - name: Check whether this release tag already exists
      id: check
      env:
        GH_TOKEN: ${{ github.token }}
        RELEASE_TAG: ${{ steps.version.outputs.release_tag }}
      run: |
        if gh release view "${RELEASE_TAG}" --repo "${{ github.repository }}" > /dev/null 2>&1; then
          echo "exists=true" >> "$GITHUB_OUTPUT"
          echo "Release ${RELEASE_TAG} already exists – skipping (use force_rebuild to override)"
        else
          echo "exists=false" >> "$GITHUB_OUTPUT"
          echo "Release ${RELEASE_TAG} not found – proceeding with build"
        fi

    - name: Determine whether to proceed
      id: gate
      run: |
        if [ "${{ steps.check.outputs.exists }}" = "false" ] || [ "${{ inputs.force_rebuild }}" = "true" ]; then
          echo "proceed=true" >> "$GITHUB_OUTPUT"
        else
          echo "proceed=false" >> "$GITHUB_OUTPUT"
        fi

    # ── Docker build & push ────────────────────────────────────────────────
    - name: Set up Docker Buildx
      if: steps.gate.outputs.proceed == 'true'
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      if: steps.gate.outputs.proceed == 'true'
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract Docker metadata
      if: steps.gate.outputs.proceed == 'true'
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/${{ github.repository_owner }}/ci-tooling-offline/${{ matrix.tool }}
        tags: |
          type=raw,value=${{ steps.version.outputs.tag }}
          type=raw,value=latest

    # Build args differ per tool
    - name: Compute build args
      if: steps.gate.outputs.proceed == 'true'
      id: buildargs
      run: |
        if [ "${{ matrix.tool }}" = "kubeconform" ]; then
          cat >> "$GITHUB_OUTPUT" <<EOF
        args<<ENDARGS
        KUBECONFORM_VERSION=${{ steps.kubeconform.outputs.version }}
        KUSTOMIZE_VERSION=${{ steps.kustomize.outputs.version }}
        ENDARGS
        EOF
        elif [ "${{ matrix.tool }}" = "gitleaks" ]; then
          cat >> "$GITHUB_OUTPUT" <<EOF
        args<<ENDARGS
        GITLEAKS_VERSION=${{ steps.gitleaks.outputs.version }}
        ENDARGS
        EOF
        fi

    - name: Build and push image
      if: steps.gate.outputs.proceed == 'true'
      uses: docker/build-push-action@v6
      with:
        context: tools/${{ matrix.tool }}
        push: true
        build-args: ${{ steps.buildargs.outputs.args }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha,scope=${{ matrix.tool }}
        cache-to: type=gha,mode=max,scope=${{ matrix.tool }}

    # ── GitHub Release (kubeconform) ───────────────────────────────────────
    - name: Create GitHub Release (kubeconform)
      if: steps.gate.outputs.proceed == 'true' && matrix.tool == 'kubeconform'
      env:
        GH_TOKEN: ${{ github.token }}
        TAG: ${{ steps.kubeconform.outputs.version }}
        KUSTOMIZE_VERSION: ${{ steps.kustomize.outputs.version }}
        RELEASE_TAG: ${{ steps.version.outputs.release_tag }}
        IMAGE: ghcr.io/${{ github.repository_owner }}/ci-tooling-offline/kubeconform
      run: |
        cat > /tmp/release-notes.md << EOF
        ## Bundled tools

        | Tool | Version |
        |------|---------|
        | [kubeconform](https://github.com/yannh/kubeconform) | \`${TAG}\` |
        | [kustomize](https://github.com/kubernetes-sigs/kustomize) | \`${KUSTOMIZE_VERSION}\` |

        ## Bundled Kubernetes JSON schemas

        The latest patch release for each minor version is included (both
        \`standalone\` and \`standalone-strict\` variants):

        - v1.33, v1.34, v1.35

        Schemas are sourced from
        [yannh/kubernetes-json-schema](https://github.com/yannh/kubernetes-json-schema).

        ## Container image

        \`\`\`
        ${IMAGE}:${TAG}
        ${IMAGE}:latest
        \`\`\`

        ## Usage in Gitea Actions

        \`\`\`yaml
        validate:
          runs-on: ubuntu-latest
          container:
            image: ${IMAGE}:${TAG}
          steps:
            - uses: actions/checkout@v4
            - run: |
                kubeconform \\
                  -kubernetes-version 1.33.0 \\
                  -schema-location "\$SCHEMA_LOCATION" \\
                  -summary manifests/
        \`\`\`

        ## Usage in GitLab CI

        \`\`\`yaml
        validate:
          image: ${IMAGE}:${TAG}
          entrypoint: [""]
          script:
            - kubeconform
                -kubernetes-version 1.33.0
                -schema-location "\$SCHEMA_LOCATION"
                -summary
                manifests/
        \`\`\`
        EOF

        gh release delete "${RELEASE_TAG}" --yes --repo "${{ github.repository }}" 2>/dev/null || true

        gh release create "${RELEASE_TAG}" \
          --repo "${{ github.repository }}" \
          --title "kubeconform ${TAG}" \
          --notes-file /tmp/release-notes.md

    # ── GitHub Release (gitleaks) ──────────────────────────────────────────
    - name: Create GitHub Release (gitleaks)
      if: steps.gate.outputs.proceed == 'true' && matrix.tool == 'gitleaks'
      env:
        GH_TOKEN: ${{ github.token }}
        GITLEAKS_VERSION: ${{ steps.gitleaks.outputs.version }}
        RELEASE_TAG: ${{ steps.version.outputs.release_tag }}
        IMAGE: ghcr.io/${{ github.repository_owner }}/ci-tooling-offline/gitleaks
      run: |
        cat > /tmp/release-notes.md << EOF
        ## Bundled tools

        | Tool | Version |
        |------|---------|
        | [gitleaks](https://github.com/gitleaks/gitleaks) | \`v${GITLEAKS_VERSION}\` |
        | node | Alpine LTS |
        | git  | Alpine latest |

        ## Container image

        \`\`\`
        ${IMAGE}:v${GITLEAKS_VERSION}
        ${IMAGE}:latest
        \`\`\`

        ### Why Node.js?

        Gitea Actions runners require Node.js to execute composite and JavaScript-based
        actions. Including it in the image ensures pipelines work in air-gapped environments.

        ## Usage in Gitea Actions

        \`\`\`yaml
        gitleaks:
          runs-on: ubuntu-latest
          container:
            image: ${IMAGE}:v${GITLEAKS_VERSION}
          steps:
            - uses: actions/checkout@v4
              with:
                fetch-depth: 0
            - run: gitleaks detect --source . --verbose --redact
        \`\`\`

        ## Usage in GitLab CI

        \`\`\`yaml
        secret-scan:
          image:
            name: ${IMAGE}:v${GITLEAKS_VERSION}
            entrypoint: [""]
          script:
            - gitleaks detect --source . --verbose
        \`\`\`
        EOF

        gh release delete "${RELEASE_TAG}" --yes --repo "${{ github.repository }}" 2>/dev/null || true

        gh release create "${RELEASE_TAG}" \
          --repo "${{ github.repository }}" \
          --title "gitleaks v${GITLEAKS_VERSION}" \
          --notes-file /tmp/release-notes.md
